package parser

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseNodeDeps(t *testing.T) {
	tmpDir := t.TempDir()
	packageJSON := filepath.Join(tmpDir, "package.json")
	
	content := `{
		"name": "test-project",
		"version": "1.0.0",
		"dependencies": {
			"express": "^4.18.2",
			"lodash": "~4.17.21",
			"axios": ">=1.4.0"
		},
		"devDependencies": {
			"jest": "^29.5.0",
			"eslint": "8.0.0"
		}
	}`
	
	if err := os.WriteFile(packageJSON, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}
	
	deps, err := ParseNodeDeps(tmpDir)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	
	// Should have 5 dependencies total (3 regular + 2 dev)
	if len(deps) != 5 {
		t.Errorf("Expected 5 dependencies, got %d", len(deps))
	}
	
	// Check that all dependencies have the correct type
	for _, dep := range deps {
		if dep.Type != "npm" {
			t.Errorf("Expected dependency type 'npm', got '%s' for %s", dep.Type, dep.Name)
		}
	}
	
	// Verify version cleaning works
	foundExpress := false
	foundLodash := false
	foundAxios := false
	
	for _, dep := range deps {
		switch dep.Name {
		case "express":
			foundExpress = true
			if dep.Version != "4.18.2" {
				t.Errorf("Expected express version '4.18.2', got '%s'", dep.Version)
			}
		case "lodash":
			foundLodash = true
			if dep.Version != "4.17.21" {
				t.Errorf("Expected lodash version '4.17.21', got '%s'", dep.Version)
			}
		case "axios":
			foundAxios = true
			if dep.Version != "1.4.0" {
				t.Errorf("Expected axios version '1.4.0', got '%s'", dep.Version)
			}
		}
	}
	
	if !foundExpress || !foundLodash || !foundAxios {
		t.Errorf("Not all expected dependencies were found")
	}
}

func TestParseNpmLock(t *testing.T) {
	tmpDir := t.TempDir()
	packageLock := filepath.Join(tmpDir, "package-lock.json")
	
	content := `{
		"name": "test-project",
		"version": "1.0.0",
		"lockfileVersion": 3,
		"packages": {
			"": {
				"name": "test-project",
				"version": "1.0.0"
			},
			"node_modules/express": {
				"version": "4.18.2"
			},
			"node_modules/lodash": {
				"version": "4.17.21"
			},
			"node_modules/@types/node": {
				"version": "20.0.0"
			},
			"node_modules/express/node_modules/body-parser": {
				"version": "1.20.1"
			}
		}
	}`
	
	if err := os.WriteFile(packageLock, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create package-lock.json: %v", err)
	}
	
	deps, err := parseNpmLock(tmpDir)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	
	// Should have 3 direct dependencies (express, lodash, @types/node)
	// body-parser should be excluded as it's nested
	if len(deps) < 3 {
		t.Errorf("Expected at least 3 dependencies, got %d", len(deps))
	}
	
	// Verify specific dependencies
	foundExpress := false
	foundLodash := false
	foundTypesNode := false
	
	for _, dep := range deps {
		if dep.Type != "npm" {
			t.Errorf("Expected dependency type 'npm', got '%s' for %s", dep.Type, dep.Name)
		}
		
		switch dep.Name {
		case "express":
			foundExpress = true
			if dep.Version != "4.18.2" {
				t.Errorf("Expected express version '4.18.2', got '%s'", dep.Version)
			}
		case "lodash":
			foundLodash = true
			if dep.Version != "4.17.21" {
				t.Errorf("Expected lodash version '4.17.21', got '%s'", dep.Version)
			}
		case "@types/node":
			foundTypesNode = true
			if dep.Version != "20.0.0" {
				t.Errorf("Expected @types/node version '20.0.0', got '%s'", dep.Version)
			}
		}
	}
	
	if !foundExpress || !foundLodash || !foundTypesNode {
		t.Errorf("Not all expected dependencies were found")
	}
}

func TestParseYarnLock(t *testing.T) {
	tmpDir := t.TempDir()
	yarnLock := filepath.Join(tmpDir, "yarn.lock")
	
	content := `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

express@^4.18.2:
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz"

lodash@~4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz"

"@types/node@^20.0.0":
  version "20.0.0"
  resolved "https://registry.yarnpkg.com/@types/node/-/node-20.0.0.tgz"
`
	
	if err := os.WriteFile(yarnLock, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create yarn.lock: %v", err)
	}
	
	deps, err := parseYarnLock(tmpDir)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	
	if len(deps) != 3 {
		t.Errorf("Expected 3 dependencies, got %d", len(deps))
	}
	
	// Verify specific dependencies
	foundExpress := false
	foundLodash := false
	foundTypesNode := false
	
	for _, dep := range deps {
		if dep.Type != "npm" {
			t.Errorf("Expected dependency type 'npm', got '%s' for %s", dep.Type, dep.Name)
		}
		
		switch dep.Name {
		case "express":
			foundExpress = true
			if dep.Version != "4.18.2" {
				t.Errorf("Expected express version '4.18.2', got '%s'", dep.Version)
			}
		case "lodash":
			foundLodash = true
			if dep.Version != "4.17.21" {
				t.Errorf("Expected lodash version '4.17.21', got '%s'", dep.Version)
			}
		case "@types/node":
			foundTypesNode = true
			if dep.Version != "20.0.0" {
				t.Errorf("Expected @types/node version '20.0.0', got '%s'", dep.Version)
			}
		}
	}
	
	if !foundExpress || !foundLodash || !foundTypesNode {
		t.Errorf("Not all expected dependencies were found")
	}
}

func TestParsePnpmLock(t *testing.T) {
	tmpDir := t.TempDir()
	pnpmLock := filepath.Join(tmpDir, "pnpm-lock.yaml")
	
	content := `lockfileVersion: '6.0'

dependencies:
  express:
    specifier: ^4.18.2
    version: 4.18.2
  lodash:
    specifier: ~4.17.21
    version: 4.17.21

devDependencies:
  '@types/node':
    specifier: ^20.0.0
    version: 20.0.0

packages:

  /express/4.18.2:
    resolution: {integrity: sha512-abc123}
    
  /lodash/4.17.21:
    resolution: {integrity: sha512-def456}
    
  /@types/node/20.0.0:
    resolution: {integrity: sha512-ghi789}
`
	
	if err := os.WriteFile(pnpmLock, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create pnpm-lock.yaml: %v", err)
	}
	
	deps, err := parsePnpmLock(tmpDir)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	
	if len(deps) < 3 {
		t.Errorf("Expected at least 3 dependencies, got %d", len(deps))
	}
	
	// Verify specific dependencies
	foundExpress := false
	foundLodash := false
	foundTypesNode := false
	
	for _, dep := range deps {
		if dep.Type != "npm" {
			t.Errorf("Expected dependency type 'npm', got '%s' for %s", dep.Type, dep.Name)
		}
		
		switch dep.Name {
		case "express":
			foundExpress = true
			if dep.Version != "4.18.2" {
				t.Errorf("Expected express version '4.18.2', got '%s'", dep.Version)
			}
		case "lodash":
			foundLodash = true
			if dep.Version != "4.17.21" {
				t.Errorf("Expected lodash version '4.17.21', got '%s'", dep.Version)
			}
		case "@types/node":
			foundTypesNode = true
			if dep.Version != "20.0.0" {
				t.Errorf("Expected @types/node version '20.0.0', got '%s'", dep.Version)
			}
		}
	}
	
	if !foundExpress || !foundLodash || !foundTypesNode {
		t.Errorf("Not all expected dependencies were found")
	}
}

func TestParseNodeDeps_PrefersLockfile(t *testing.T) {
	tmpDir := t.TempDir()
	
	// Create package.json with version ranges
	packageJSON := filepath.Join(tmpDir, "package.json")
	packageContent := `{
		"dependencies": {
			"express": "^4.18.0"
		}
	}`
	if err := os.WriteFile(packageJSON, []byte(packageContent), 0644); err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}
	
	// Create package-lock.json with exact version
	packageLock := filepath.Join(tmpDir, "package-lock.json")
	lockContent := `{
		"packages": {
			"": {},
			"node_modules/express": {
				"version": "4.18.2"
			}
		}
	}`
	if err := os.WriteFile(packageLock, []byte(lockContent), 0644); err != nil {
		t.Fatalf("Failed to create package-lock.json: %v", err)
	}
	
	deps, err := ParseNodeDeps(tmpDir)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	
	// Should use exact version from lockfile, not range from package.json
	for _, dep := range deps {
		if dep.Name == "express" {
			if dep.Version != "4.18.2" {
				t.Errorf("Expected exact version '4.18.2' from lockfile, got '%s'", dep.Version)
			}
			return
		}
	}
	
	t.Errorf("express dependency not found")
}

func TestParseNodeDeps_NoFile(t *testing.T) {
	tmpDir := t.TempDir()
	
	_, err := ParseNodeDeps(tmpDir)
	if err == nil {
		t.Errorf("Expected error for missing package.json, got nil")
	}
}

func TestParseNodeDeps_InvalidJSON(t *testing.T) {
	tmpDir := t.TempDir()
	packageJSON := filepath.Join(tmpDir, "package.json")
	
	// Invalid JSON
	content := `{invalid json`
	
	if err := os.WriteFile(packageJSON, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}
	
	_, err := ParseNodeDeps(tmpDir)
	if err == nil {
		t.Errorf("Expected error for invalid JSON, got nil")
	}
}

func TestCleanVersion(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"^4.18.2", "4.18.2"},
		{"~4.17.21", "4.17.21"},
		{">=1.4.0", "1.4.0"},
		{"<=2.0.0", "2.0.0"},
		{">1.0.0", "1.0.0"},
		{"<3.0.0", "3.0.0"},
		{"=1.5.0", "1.5.0"},
		{"1.2.3", "1.2.3"}, // No prefix
	}
	
	for _, tt := range tests {
		result := cleanVersion(tt.input)
		if result != tt.expected {
			t.Errorf("cleanVersion(%q) = %q, expected %q", tt.input, result, tt.expected)
		}
	}
}

func TestParseNodeDeps_EmptyDependencies(t *testing.T) {
	tmpDir := t.TempDir()
	packageJSON := filepath.Join(tmpDir, "package.json")
	
	content := `{
		"name": "test-project",
		"version": "1.0.0"
	}`
	
	if err := os.WriteFile(packageJSON, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}
	
	deps, err := ParseNodeDeps(tmpDir)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	
	if len(deps) != 0 {
		t.Errorf("Expected 0 dependencies, got %d", len(deps))
	}
}

